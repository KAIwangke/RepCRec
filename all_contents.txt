Directory Contents Dump - Sat Dec  7 22:12:41 UTC 2024
Current Directory: /root/RepCRec
=========================================

=== File: ./test/test7.txt ===
----------------------------------------
begin(T1)
begin(T2)
R(T2,x1)
R(T2,x2)
W(T1,x3,33)
end(T1)
R(T2,x3)
end(T2)


=== File: ./test/test9.txt ===
----------------------------------------
begin(T3)
begin(T1)
begin(T2)
W(T3,x2,22)
W(T2,x4,44)
R(T3,x4)
end(T2)
end(T3)
R(T1,x2)
end(T1)


=== File: ./test/test20.txt ===
----------------------------------------
begin(T1)
begin(T2)
R(T2, x2)
W(T1, x2, 202)
W(T2, x2, 302)
end(T1)
end(T2)
dump()


=== File: ./test/test10.txt ===
----------------------------------------
begin(T2)
begin(T3)
W(T3,x2,22)
W(T2,x4,44)
R(T3,x4)
end(T2)
end(T3)
begin(T1)
R(T1,x2)
end(T1)



=== File: ./test/test3_5.txt ===
----------------------------------------
begin(T1)
begin(T2)
R(T1,x3)
W(T2,x8,88)
fail(2)
R(T2,x3)
W(T1, x4,91)
recover(2)
end(T2)
end(T1)


=== File: ./test/test14.txt ===
----------------------------------------
begin(T1)
begin(T2)
begin(T3)
W(T3,x2,10)
W(T1,x2,20)
W(T2,x2,30)
end(T1)
end(T3)
end(T2)



=== File: ./test/test12.txt ===
----------------------------------------
begin(T1)
begin(T2)
R(T1,x2)
R(T2,x2)
end(T1)
W(T2,x2,10)
end(T2)


=== File: ./test/test6.txt ===
----------------------------------------
begin(T1)
begin(T2)
fail(3) 
fail(4)
R(T1,x1)
W(T2,x8,88)
end(T1)
recover(4) 
recover(3)
R(T2,x3)
end(T2)
dump()


=== File: ./test/test22.txt ===
----------------------------------------
begin(T1)
begin(T2)
W(T1, x2, 80)
W(T1, x4, 50)
R(T2, x4)
end(T1) 
W(T2, x6, 90)
begin(T3)
R(T3, x6)
W(T3, x2, 70)
end(T2) 
end(T3) 


=== File: ./test/test15.txt ===
----------------------------------------
begin(T5)
begin(T4)
begin(T3)
begin(T2)
begin(T1)
W(T1,x4, 5)
fail(2)
W(T2,x4,44)
recover(2)
W(T3,x4,55)
W(T4,x4,66)
W(T5,x4,77)
end(T1)
end(T2)
end(T3)
end(T4)
end(T5)


=== File: ./test/test23.txt ===
----------------------------------------
begin(T1)
begin(T2)
fail(3)
fail(4)
R(T1,x1)
W(T2,x8,88)
end(T1)
recover(4)
recover(3)
R(T2,x3)
end(T2)
fail(1)
fail(2)
fail(5)
fail(6)
fail(7)
fail(8)
fail(9)
fail(10)
begin(T3)
R(T3,x8)


=== File: ./test/test11.txt ===
----------------------------------------
begin(T1)
begin(T2)
R(T1,x2)
R(T2,x2)
W(T2,x2,10)
end(T1)
end(T2)


=== File: ./test/test19.txt ===
----------------------------------------
begin(T1)
begin(T2)
begin(T3)
begin(T4)
begin(T5)
W(T3,x3,300)
fail(4)
recover(4)
R(T4,x4)
R(T5,x5)
R(T1,x6)
R(T2,x2)
W(T1,x2,10)
W(T2,x3,20)
W(T3,x4,30)
W(T5,x1,50)
end(T5)
W(T4,x5,40)
end(T4)
end(T3)
end(T2)
end(T1)


=== File: ./test/test2.txt ===
----------------------------------------
begin(T1)
begin(T2)
W(T1,x1,101) 
R(T2,x2)
W(T1,x2,102) 
R(T2,x1)
end(T1)
end(T2)
dump()


=== File: ./test/test4.txt ===
----------------------------------------
begin(T1)
begin(T2)
W(T1,x1,512)
fail(2)
W(T2,x8,88) 
R(T2,x3)
R(T1, x5)
end(T2)
recover(2)
end(T1)


=== File: ./test/test18.txt ===
----------------------------------------
begin(T1)
begin(T2)
begin(T3)
begin(T4)
begin(T5)
R(T4,x4)
R(T5,x5)
R(T1,x1)
W(T1,x2,10)
R(T2,x2)
W(T2,x3,20)
R(T3,x3)
W(T3,x4,30)
W(T4,x5,40)
W(T5,x1,50)
end(T4)
end(T3)
end(T2)
end(T1)
end(T5)


=== File: ./test/test21.txt ===
----------------------------------------
begin(T1)
begin(T2)
R(T1, x2)
R(T2, x4)
W(T1, x4, 30)
W(T2, x2, 90)
end(T1)
end(T2) 


=== File: ./test/test16.txt ===
----------------------------------------
begin(T3)
begin(T2)
W(T3,x2,22)
W(T2,x4,44)
R(T3,x4)
end(T2)
end(T3)
begin(T1)
R(T1,x2)
end(T1)


=== File: ./test/test3_7.txt ===
----------------------------------------
begin(T1)
begin(T2)
R(T1,x3)
W(T2,x8,88) 
fail(2)
R(T2,x3)
recover(2)
W(T1, x4,91)
end(T2)
end(T1)



=== File: ./test/test5.txt ===
----------------------------------------
begin(T1)
begin(T2)
W(T1,x6,66)
fail(2)
W(T2,x8,88) 
R(T2,x3)
R(T1, x5)
end(T2)
recover(2)
end(T1)


=== File: ./test/test25.txt ===
----------------------------------------
begin(T1)
begin(T2)
fail(3)
fail(4)
R(T1,x1)
W(T2,x8,88)
end(T1)
recover(4)
recover(3)
R(T2,x3)
end(T2)
fail(1)
fail(5)
fail(6)
fail(7)
fail(8)
fail(9)
fail(10)
begin(T3)
fail(2)
begin(T4)
W(T4,x8,99)
end(T4)                    
R(T3,x8)
recover(2)
end(T3)


=== File: ./test/test1.txt ===
----------------------------------------
begin(T1)
begin(T2)
W(T1,x1,101) 
W(T2,x2,202)
W(T1,x2,102) 
W(T2,x1,201)
end(T2)
end(T1)
dump()


=== File: ./test/test8.txt ===
----------------------------------------
begin(T1)
begin(T2)
R(T2,x1)
R(T2,x2)
W(T1,x3,33)
end(T1)
begin(T3)
R(T3,x3)
R(T2,x3)
end(T2)
end(T3)


=== File: ./test/test24.txt ===
----------------------------------------
begin(T1)
begin(T2)
fail(3)
fail(4)
R(T1,x1)
W(T2,x8,88)
end(T1)
recover(4)
recover(3)
R(T2,x3)
end(T2)
fail(1)
fail(2)
fail(5)
fail(6)
fail(7)
fail(8)
fail(9)
fail(10)
begin(T3)
begin(T4)
W(T4,x8,99)
end(T4)                    
R(T3,x8)


=== File: ./test/test3.txt ===
----------------------------------------
begin(T1)
begin(T2)
R(T1,x3)
fail(2)
W(T2,x8,88) 
R(T2,x3)
W(T1, x5,91)
end(T2)
recover(2)
end(T1)


=== File: ./test/test17.txt ===
----------------------------------------
begin(T3)
begin(T2)
W(T3,x2,22)
W(T2,x3,44)
R(T3,x3)
end(T2)
fail(4)
end(T3)
begin(T1)
R(T1,x2)
end(T1)


=== File: ./test/test13.txt ===
----------------------------------------
begin(T1)
begin(T2)
begin(T3)
W(T3,x2,10)
W(T2,x2,20)
W(T1,x2,30)
end(T3)
end(T2)
end(T1)



=== File: ./README.md ===
----------------------------------------
Collaboration Plan

Part1: Transaction Management
1. Implement the TransactionManager class, focusing on SSI logic.
2. Develop the Transaction class to store transaction data.
3. Implement command parsing in CommandParser and integrate it with TransactionManager.
4. Handle transaction lifecycle: begin, read, write, validate, commit, abort.
5. Implement conflict detection and resolution according to SSI rules.

Part 2: Data Management
1. Implement the DataManager class to manage sites.
2. Develop the Site class to handle variables, failures, and recoveries.
3. Implement the Variable class with versioning to support SSI.
4. Handle read and write operations at the site level, considering replication.
5. Implement site failure and recovery logic, ensuring proper variable availability.


test cases: https://cs.nyu.edu/courses/fall24/CSCI-GA.2434-001/projectsampletests.serializablesnapshotisolation



=== File: ./CMakeLists.txt ===
----------------------------------------
# Minimum CMake version required
cmake_minimum_required(VERSION 3.10)

# Project Name
project(RepCRec)

# Set C++ standard
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# Set the source and include directory variables
set(SOURCE_DIR "${PROJECT_SOURCE_DIR}/src")
set(INCLUDE_DIR "${PROJECT_SOURCE_DIR}/include")
set(TEST_DIR "${PROJECT_SOURCE_DIR}/test")

# Include directories
include_directories(
    ${INCLUDE_DIR}
    ${SOURCE_DIR}
)

# Source files with correct paths
set(SOURCES
    ${SOURCE_DIR}/main.cpp
    ${SOURCE_DIR}/LockTable.cpp
    ${SOURCE_DIR}/data/DataManager.cpp
    ${SOURCE_DIR}/data/Site.cpp
    ${SOURCE_DIR}/data/Variable.cpp
    ${SOURCE_DIR}/transaction/Transaction.cpp
    ${SOURCE_DIR}/transaction/TransactionManager.cpp
    ${SOURCE_DIR}/transaction/CommandParser.cpp
)

# Add executable
add_executable(${PROJECT_NAME} ${SOURCES})

# Function to create test target
function(create_test_target TEST_NAME TEST_FILE)
    add_custom_target(${TEST_NAME}
        COMMAND ${CMAKE_COMMAND} -E copy ${TEST_FILE} ${CMAKE_BINARY_DIR}/${TEST_NAME}.txt
        COMMAND ${PROJECT_NAME} ${TEST_NAME}.txt
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
        DEPENDS ${PROJECT_NAME}
    )
endfunction()

# Find all test files
file(GLOB TEST_FILES "${TEST_DIR}/test*.txt")

# Create all test targets
foreach(TEST_FILE ${TEST_FILES})
    get_filename_component(TEST_NAME ${TEST_FILE} NAME_WE)
    create_test_target(${TEST_NAME} ${TEST_FILE})
endforeach()

# Add a target to run all tests
add_custom_target(test
    DEPENDS ${PROJECT_NAME}
)

# Make test depend on all individual test targets
foreach(TEST_FILE ${TEST_FILES})
    get_filename_component(TEST_NAME ${TEST_FILE} NAME_WE)
    add_dependencies(test ${TEST_NAME})
endforeach()

# Create a target to copy all test files
add_custom_target(copy_test_files)

foreach(TEST_FILE ${TEST_FILES})
    get_filename_component(TEST_NAME ${TEST_FILE} NAME)
    add_custom_command(
        TARGET copy_test_files
        COMMAND ${CMAKE_COMMAND} -E copy ${TEST_FILE} ${CMAKE_BINARY_DIR}/${TEST_NAME}
    )
endforeach()

# Make the executable depend on copying test files
add_dependencies(${PROJECT_NAME} copy_test_files)


=== File: ./src/main.cpp ===
----------------------------------------
/**
 * @ Author: Ke Wang & Siwen Tao
 * @ Email: kw3484@nyu.edu & st5297@nyu.edu
 * @ Create Time: 2024-11-26 20:07:56
 * @ Modified time: 2024-12-05 21:32:40
 */

#include <iostream>
#include <fstream>
#include <memory>
#include <string>
#include "TransactionManager.h"
#include "DataManager.h"
#include "CommandParser.h"

int main(int argc, char* argv[]) {
    auto dataManager = std::make_shared<DataManager>();
    TransactionManager transactionManager(dataManager);
    CommandParser parser(transactionManager);

    std::istream* input = &std::cin; // Default to standard input
    std::ifstream inputFile;

    // If filename provided as command line argument
    if (argc > 1) {
        inputFile.open(argv[1]);
        if (!inputFile.is_open()) {
            std::cerr << "Failed to open input file '" << argv[1] << "'.\n";
            return 1;
        }
        input = &inputFile;
    }

    std::string command;
    while (std::getline(*input, command)) {
        // Skip empty lines or comments
        if (command.empty() || command[0] == '/') {
            continue;
        }

        // Process each command immediately
        parser.parseCommand(command);

        // Flush output after each command to ensure sequential output
        std::cout.flush();
    }

    if (inputFile.is_open()) {
        inputFile.close();
    }

    return 0;
}


=== File: ./src/data/Site.cpp ===
----------------------------------------
/**
 * @ Author: Ke Wang & Siwen Tao
 * @ Email: kw3484@nyu.edu & st5297@nyu.edu
 * @ Create Time: 2024-11-26 20:07:56
 * @ Modified time: 2024-12-05 21:32:59
 */

#include "Site.h"
#include <iostream>
#include <chrono>
#include <string>
#include <algorithm>
using namespace std;

Site::Site(int id) : id(id), status(SiteStatus::UP)
{
    initializeVariables();
}

int Site::getId() const
{
    return id;
}

SiteStatus Site::getStatus() const
{
    return status;
}

void Site::setStatus(SiteStatus status)
{
    this->status = status;
}

// Fixed: Added const qualifier to match the header declaration
bool Site::hasCommittedWrite(const string &variableName, long startTime) const
{
    auto it = variables.find(variableName);
    if (it != variables.end())
    {
        return it->second.wasModifiedAfter(startTime);
    }
    return false;
}

bool Site::hasVariable(const string &variableName) const
{
    return variables.find(variableName) != variables.end();
}

int Site::readVariable(const std::string &variableName, long timestamp) {
    std::lock_guard<std::mutex> lock(siteMutex);

    if (status == SiteStatus::DOWN) {
        throw std::runtime_error("Site is down.");
    }

    // Allow reading even if variable is unavailable if we have a version before timestamp
    auto it = variables.find(variableName);
    if (it != variables.end()) {
        return it->second.readValue(timestamp);
    }

    throw std::runtime_error("Variable " + variableName + " not found");
}

void Site::writeVariable(const std::string &variableName, int value, long commitTime)
{
    std::lock_guard<std::mutex> lock(siteMutex);
    variables[variableName].writeValue(value, commitTime);

    // If variable was unavailable for reading, now it becomes available
    unavailableVariables.erase(variableName);
}



void Site::dump() const
{
    cout << "=== Site " << id << " ===" << endl;
    if (status == SiteStatus::DOWN)
    {
        cout << "Site " << id << " is down" << endl;
        return;
    }

    bool hasModifiedVars = false;

    // Check for and print modified odd variables at this site
    for (const auto &pair : variables)
    {
        string varName = pair.first;
        int varIndex = stoi(varName.substr(1));
        if (varIndex % 2 == 1)
        { // odd variable
            int value = pair.second.readValue(chrono::system_clock::now().time_since_epoch().count());
            int initialValue = varIndex * 10;
            if (value != initialValue)
            {
                cout << varName << ": " << value << endl;
                hasModifiedVars = true;
            }
        }
    }

    // Check for and print modified even variables
    for (const auto &pair : variables)
    {
        string varName = pair.first;
        int varIndex = stoi(varName.substr(1));
        if (varIndex % 2 == 0)
        { // even variable
            int value = pair.second.readValue(chrono::system_clock::now().time_since_epoch().count());
            int initialValue = varIndex * 10;
            if (value != initialValue)
            {
                cout << varName << ": " << value << " at all sites" << endl;
                hasModifiedVars = true;
                break; // Only need to show once for replicated variables
            }
        }
    }

    if (!hasModifiedVars)
    {
        cout << "All variables have their initial values" << endl;
    }
}



void Site::initializeVariables()
{
    for (int i = 1; i <= 20; ++i)
    {
        std::string varName = "x" + std::to_string(i);
        int initialValue = i * 10;
        if (i % 2 == 0)
        {
            // Even-indexed variable, replicated at all sites
            variables[varName] = Variable(varName, initialValue);
        }
        else
        {
            // Odd-indexed variable, stored at one site
            int assignedSite = 1 + (i % 10);
            if (assignedSite == id)
            {
                variables[varName] = Variable(varName, initialValue);
            }
        }
    }
}

const std::vector<std::pair<long, long>> &Site::getFailureTimes() const
{
    return failureTimes;
}


void Site::fail() {
    std::unique_lock<std::mutex> lock(siteMutex);
    if (status == SiteStatus::DOWN) {
        // Already down, don't do anything
        return;
    }
    status = SiteStatus::DOWN;
    long failTime = std::chrono::system_clock::now().time_since_epoch().count();
    failureTimes.emplace_back(failTime, -1);
    unavailableVariables.clear();
}

void Site::recover() {
    std::unique_lock<std::mutex> lock(siteMutex);
    if (status != SiteStatus::DOWN) {
        // Not down, can't recover
        return;
    }
    status = SiteStatus::RECOVERING;
    long recoverTime = std::chrono::system_clock::now().time_since_epoch().count();
    if (!failureTimes.empty() && failureTimes.back().second == -1) {
        failureTimes.back().second = recoverTime;
    }

    // Mark replicated variables as unavailable until a new write
    for (const auto &varPair : variables) {
        int varIndex = stoi(varPair.first.substr(1));
        if (varIndex % 2 == 0) {
            unavailableVariables.insert(varPair.first);
        }
    }
}


=== File: ./src/data/DataManager.cpp ===
----------------------------------------
/**
 * @ Author: Ke Wang & Siwen Tao
 * @ Email: kw3484@nyu.edu & st5297@nyu.edu
 * @ Create Time: 2024-11-26 20:07:56
 * @ Modified time: 2024-12-05 21:33:02
 */

#include "DataManager.h"
#include <iostream>
using namespace std;

DataManager::DataManager()
{
    initializeSites();
}

void DataManager::initializeSites()
{
    for (int i = 1; i <= 10; ++i)
    {
        sites[i] = std::make_shared<Site>(i);
    }
}

std::shared_ptr<Site> DataManager::getSite(int siteId)
{
    return sites[siteId];
}

std::vector<std::shared_ptr<Site>> DataManager::getAllSites()
{
    std::vector<std::shared_ptr<Site>> siteList;
    for (auto &pair : sites)
    {
        siteList.push_back(pair.second);
    }
    return siteList;
}

bool DataManager::hasCommittedWrite(const std::string &variableName, long startTime)
{
    for (const auto &sitePair : sites)
    {
        auto site = sitePair.second;
        if (site->hasCommittedWrite(variableName, startTime))
        {
            return true;
        }
    }
    return false;
}

void DataManager::commitTransaction(std::shared_ptr<Transaction> transaction)
{
    for (const auto &write : transaction->getWriteSet())
    {
        const std::string &variableName = write.first;
        int value = write.second;
        DataManager::write(transaction, variableName, value, transaction->getCommitTime());
    }
}



void DataManager::write(std::shared_ptr<Transaction> transaction, const std::string &variableName, int value, long commitTime)
{
    int varIndex = stoi(variableName.substr(1));

    if (varIndex % 2 == 0)
    { // Even variables - write to all up sites
        for (auto &sitePair : sites)
        {
            auto site = sitePair.second;
            if (site->getStatus() == SiteStatus::UP && site->hasVariable(variableName))
            {
                site->writeVariable(variableName, value, commitTime);
            }
        }
    }
    else
    { // Odd variables - write to specific site
        int siteId = 1 + (varIndex % 10);
        auto site = sites[siteId];
        if (site->getStatus() == SiteStatus::UP && site->hasVariable(variableName))
        {
            site->writeVariable(variableName, value, commitTime);
        }
    }
}


void DataManager::dump()
{
    for (const auto &sitePair : sites)
    {
        sitePair.second->dump();
    }
}

#include "DataManager.h"
#include <iostream>
using namespace std;

bool DataManager::hasSiteStableHistory(std::shared_ptr<Site> site, long timestamp) const {
    if (!site || site->getStatus() == SiteStatus::DOWN) {
        return false;
    }

    const auto& failureTimes = site->getFailureTimes();
    for (const auto& ft : failureTimes) {
        // Check if there was a failure between transaction start and current time
        if (ft.first <= timestamp && (ft.second == -1 || ft.second > timestamp)) {
            return false;
        }
    }
    return true;
}

bool DataManager::hasContinuousHistory(std::shared_ptr<Site> site, long fromTime, long toTime) const {
    const auto& failureTimes = site->getFailureTimes();
    for (const auto& ft : failureTimes) {
        // Check if any failure interval overlaps with [fromTime, toTime]
        if (ft.first <= toTime && (ft.second == -1 || ft.second >= fromTime)) {
            return false;
        }
    }
    return true;
}

int DataManager::read(const string& transactionName, const string& variableName, long timestamp) {
    int varIndex = stoi(variableName.substr(1));

    if (varIndex % 2 == 1) { // Odd variables
        int siteId = 1 + (varIndex % 10);
        auto site = sites[siteId];
        if (site->getStatus() == SiteStatus::DOWN) {
            throw runtime_error("Site " + to_string(siteId) + " is down");
        }
        return site->readVariable(variableName, timestamp);
    }
    else { // Even variables
        // First find if there is any site that has a valid history of the variable
        long lastWriteTime = -1;
        bool foundValidVersion = false;
        
        for (auto& sitePair : sites) {
            auto site = sitePair.second;
            if (site->hasVariable(variableName) && 
                hasContinuousHistory(site, lastWriteTime, timestamp)) {
                foundValidVersion = true;
                break;
            }
        }

        // If no site has valid version, abort immediately
        if (!foundValidVersion) {
            throw runtime_error("No valid version of " + variableName);
        }

        // Try to read from an up site with valid version
        for (auto& sitePair : sites) {
            auto site = sitePair.second;
            if (site->getStatus() == SiteStatus::UP &&
                site->hasVariable(variableName) &&
                hasContinuousHistory(site, lastWriteTime, timestamp)) {
                try {
                    return site->readVariable(variableName, timestamp);
                } catch (...) {
                    continue;
                }
            }
        }

        // If we found a valid version but can't access it right now, wait
        cout << "Transaction " << transactionName << " waits for reading "
             << variableName << endl;
        waitingReads.push_back({transactionName, variableName, timestamp});
        throw runtime_error("Transaction must wait");
    }

    throw runtime_error("No available site to read " + variableName);
}
void DataManager::recoverSite(int siteId) {
    auto site = getSite(siteId);
    if (!site || site->getStatus() != SiteStatus::DOWN) {
        return;
    }

    site->recover();
    cout << "Site " << siteId << " recovered." << endl;

    // Process waiting reads
    auto it = waitingReads.begin();
    while (it != waitingReads.end()) {
        if (site->hasVariable(it->variableName) && 
            hasSiteStableHistory(site, it->timestamp)) {
            try {
                int value = site->readVariable(it->variableName, it->timestamp);
                cout << it->variableName << ": " << value << endl;
                it = waitingReads.erase(it);
                continue;
            } catch (...) {}
        }
        ++it;
    }
}


void DataManager::failSite(int siteId) {
    auto site = getSite(siteId);
    if (!site) return;
    
    if (site->getStatus() != SiteStatus::DOWN) {
        site->fail();
        cout << "Site " << siteId << " failed." << endl;
    }
}



=== File: ./src/data/Variable.cpp ===
----------------------------------------
/**
 * @ Author: Ke Wang & Siwen Tao
 * @ Email: kw3484@nyu.edu & st5297@nyu.edu
 * @ Create Time: 2024-11-26 20:07:56
 * @ Modified time: 2024-12-05 21:32:57
 */

#include "Variable.h"


Variable::Variable()
    : name(""), versions({{0, 0}}) {} // Initialize members appropriately
    
Variable::Variable(const std::string& name, int initialValue)
    : name(name) {
    versions.push_back({initialValue, 0}); // Initial version at time 0
}

std::string Variable::getName() const {
    return name;
}

int Variable::readValue(long timestamp) const {
    // Return initial value if no versions exist
    if (versions.empty()) {
        return stoi(name.substr(1)) * 10;
    }
    
    // Return value of latest version before or at timestamp
    for (auto it = versions.rbegin(); it != versions.rend(); ++it) {
        if (it->commitTime <= timestamp) {
            return it->value;
        }
    }
    
    // If no appropriate version found, return initial value
    return stoi(name.substr(1)) * 10;
}

bool Variable::wasModifiedAfter(long timestamp) const {
    for (const auto& version : versions) {
        if (version.commitTime > timestamp) {
            return true;
        }
    }
    return false;
}

void Variable::writeValue(int value, long commitTime) {
    versions.push_back({value, commitTime});
}




=== File: ./src/LockTable.cpp ===
----------------------------------------
/**
 * @ Author: Ke Wang & Siwen Tao
 * @ Email: kw3484@nyu.edu & st5297@nyu.edu
 * @ Create Time: 2024-11-26 20:07:56
 * @ Modified time: 2024-12-05 21:32:27
 */

#include "Lock.h"

Lock::Lock(Lock_type type, set<int> transactions)
{
    this->type = type;
    this->transactions = transactions;
}


=== File: ./src/transaction/TransactionManager.cpp ===
----------------------------------------
/**
 * @ Author: Ke Wang & Siwen Tao
 * @ Email: kw3484@nyu.edu & st5297@nyu.edu
 * @ Create Time: 2024-12-05 20:25:29
 * @ Modified time: 2024-12-05 21:32:36
 */

#include "TransactionManager.h"
#include "CommandParser.h"
#include <iostream>
#include <chrono>
#include <string>
#include <regex>

using namespace std;

TransactionManager::TransactionManager(shared_ptr<DataManager> dm)
    : dataManager(dm) {}

namespace
{
    // Helper function to extract variable index from name (e.g., "x3" -> 3)
    int getVarIndex(const string &varName)
    {
        regex rx("x(\\d+)");
        smatch match;
        if (regex_match(varName, match, rx))
        {
            return stoi(match[1]);
        }
        return -1;
    }
}

void TransactionManager::beginTransaction(const string &transactionName, bool isReadOnly)
{
    if (transactions.find(transactionName) != transactions.end())
    {
        cout << "Transaction " << transactionName << " already exists.\n";
        return;
    }

    auto transaction = make_shared<Transaction>(transactionName, isReadOnly);
    transactions[transactionName] = transaction;
    cout << "Transaction " << transactionName << " started"
         << (isReadOnly ? " (Read-Only)" : "") << ".\n";
}

void TransactionManager::read(const string &transactionName, const string &variableName)
{
    auto it = transactions.find(transactionName);
    if (it == transactions.end() || it->second->getStatus() != TransactionStatus::ACTIVE)
    {
        cout << "Transaction " << transactionName << " is not active.\n";
        return;
    }

    auto transaction = it->second;
    int varIndex = getVarIndex(variableName);
    if (varIndex < 1 || varIndex > 20)
    {
        cout << "Invalid variable name: " << variableName << endl;
        abortTransaction(transaction);
        return;
    }

    try
    {
        int value = dataManager->read(transactionName, variableName, transaction->getStartTime());
        transaction->addReadVariable(variableName);
        cout << variableName << ": " << value << endl;
        readTable[variableName].insert(transaction->getName());
    }
    catch (const runtime_error &e)
    {
        string errorMsg = e.what();
        if (errorMsg == "Transaction must wait")
        {
            return; // Don't abort - transaction is waiting
        }
        // For any other error, abort the transaction
        abortTransaction(transaction);
    }
}
void TransactionManager::write(const string &transactionName, const string &variableName, int value)
{
    auto it = transactions.find(transactionName);
    if (it == transactions.end() || it->second->getStatus() != TransactionStatus::ACTIVE)
    {
        cout << "Transaction " << transactionName << " is not active.\n";
        return;
    }

    auto transaction = it->second;
    if (transaction->isReadOnly())
    {
        cout << "Read-only transaction " << transactionName << " cannot perform writes.\n";
        abortTransaction(transaction);
        return;
    }

    int varIndex = getVarIndex(variableName);
    if (varIndex < 1 || varIndex > 20)
    {
        cout << "Invalid variable name: " << variableName << endl;
        abortTransaction(transaction);
        return;
    }

    // Determine which sites this write would affect
    std::vector<int> siteIdsToWrite;
    if (varIndex % 2 == 0)
    { // Even variable, replicated
        for (const auto &site : dataManager->getAllSites())
        {
            // Include only sites that are UP
            if (site->getStatus() == SiteStatus::UP)
            {
                if (site->hasVariable(variableName))
                {
                    siteIdsToWrite.push_back(site->getId());
                }
            }
        }
    }
    else
    { // Odd variable, located at one site
        int siteId = 1 + (varIndex % 10);
        auto site = dataManager->getSite(siteId);
        // Include only if the site is UP
        if (site && site->getStatus() == SiteStatus::UP)
        {
            if (site->hasVariable(variableName))
            {
                siteIdsToWrite.push_back(siteId);
            }
        }
    }

    // Update the transaction's sitesWrittenTo set
    transaction->addSitesWritten(siteIdsToWrite);

    // Buffer the write
    transaction->addWriteVariable(variableName, value);
    cout << "Write of " << value << " to " << variableName
         << " buffered for transaction " << transactionName << endl;
}

void TransactionManager::endTransaction(const string &transactionName)
{
    auto it = transactions.find(transactionName);
    if (it == transactions.end())
    {
        cout << "Transaction " << transactionName << " not found.\n";
        return;
    }

    auto transaction = it->second;
    if (transaction->getStatus() != TransactionStatus::ACTIVE)
    {
        cout << "Transaction " << transactionName << " is not active.\n";
        return;
    }

    // Validate and commit/abort the transaction
    validateAndCommit(transaction);

    // Clean up transaction entry
    // transactions.erase(it);
}

void TransactionManager::validateAndCommit(std::shared_ptr<Transaction> transaction)
{
    if (transaction->isReadOnly())
    {
        // Read-only transactions can commit without checks
        transaction->setStatus(TransactionStatus::COMMITTED);
        std::cout << transaction->getName() << " committed (Read-Only)." << std::endl;
        return;
    }

    long transactionStartTime = transaction->getStartTime();
    long transactionCommitTime = std::chrono::system_clock::now().time_since_epoch().count();

    // Check if any site written by this transaction failed during its lifetime
    for (int siteId : transaction->getSitesWrittenTo())
    {
        auto site = dataManager->getSite(siteId);
        if (site)
        {
            const auto &failureTimes = site->getFailureTimes();
            for (auto &ft : failureTimes)
            {
                long failTime = ft.first;
                long recoverTime = ft.second;
                if (failTime <= transactionCommitTime &&
                    (recoverTime == -1 || recoverTime >= transactionStartTime))
                {
                    std::cout << transaction->getName() << " aborts due to failure of site " << siteId << std::endl;
                    abortTransaction(transaction);
                    return;
                }
            }
        }
    }

    // First committer wins for write-write conflicts
    for (const auto &writePair : transaction->getWriteSet())
    {
        const std::string &variableName = writePair.first;
        if (lastWriter.find(variableName) != lastWriter.end() &&
            lastWriter[variableName] != transaction->getName())
        {
            std::cout << transaction->getName() << " aborts due to first committer wins on " << variableName << std::endl;
            abortTransaction(transaction);
            return;
        }
    }

    // ---------------------------------------------------------------------------
    // Add Dependencies for RW Conflicts - BOTH Directions
    //
    // 1) For each variable read by this transaction, add an edge from all writers
    //    of that variable to this transaction. (Writer → Reader)
    for (const auto &variableName : transaction->getReadSet())
    {
        // All transactions that wrote this variable in the past
        for (const auto &writerTransactionName : writeTable[variableName])
        {
            if (writerTransactionName != transaction->getName())
            {
                transaction->addDependency(writerTransactionName);
            }
        }
    }

    // 2) For each variable written by this transaction, add an edge from every reader
    //    that read this variable (before this write) to the current transaction.
    //    (Reader → Writer)
    for (const auto &[variableName, value] : transaction->getWriteSet())
    {
        // If there was a previous writer, add that dependency as well (WW dependency)
        if (lastWriter.find(variableName) != lastWriter.end())
        {
            const std::string &prevWriter = lastWriter[variableName];
            if (prevWriter != transaction->getName())
            {
                transaction->addDependency(prevWriter);
            }
        }

        // Now handle Reader → Writer edges: all transactions that previously read this variable
        // must come before this transaction.
        for (const auto &readerTransactionName : readTable[variableName])
        {
            if (readerTransactionName != transaction->getName())
            {
                transaction->addDependency(readerTransactionName);
            }
        }
    }
    // ---------------------------------------------------------------------------

    // Check for cycles in the dependency graph
    if (detectCycle(transaction->getName()))
    {
        std::cout << transaction->getName() << " aborts due to cycle in dependency graph." << std::endl;
        abortTransaction(transaction);
        return;
    }

    // If no conflicts or cycles, commit
    long commitTime = std::chrono::system_clock::now().time_since_epoch().count();
    transaction->setCommitTime(commitTime);

    // Perform the actual database writes
    dataManager->commitTransaction(transaction);

    // Update lastWriter for all variables written by this transaction
    for (const auto &[variableName, val] : transaction->getWriteSet())
    {
        lastWriter[variableName] = transaction->getName();
        writeTable[variableName].insert(transaction->getName());
    }

    // Update readTable for variables read
    for (const auto &variableName : transaction->getReadSet())
    {
        readTable[variableName].insert(transaction->getName());
    }

    transaction->setStatus(TransactionStatus::COMMITTED);
    std::cout << transaction->getName() << " committed." << std::endl;
}

void TransactionManager::abortTransaction(shared_ptr<Transaction> transaction)
{
    transaction->setStatus(TransactionStatus::ABORTED);
    cout << "Transaction " << transaction->getName() << " aborted.\n";
}

void TransactionManager::dump() const
{
    dataManager->dump();
}

void TransactionManager::failSite(int siteId)
{
    dataManager->failSite(siteId);
}

void TransactionManager::recoverSite(int siteId)
{
    dataManager->recoverSite(siteId);
}

bool TransactionManager::detectCycle(const std::string &transactionName)
{
    std::set<std::string> visited;
    std::set<std::string> recursionStack;
    return dfs(transactionName, visited, recursionStack);
}

bool TransactionManager::dfs(const std::string &transactionName, std::set<std::string> &visited, std::set<std::string> &recursionStack)
{
    if (recursionStack.count(transactionName))
    {
        // Cycle detected
        return true;
    }
    if (visited.count(transactionName))
    {
        // Already visited
        return false;
    }
    visited.insert(transactionName);
    recursionStack.insert(transactionName);

    auto transaction = transactions[transactionName];
    for (const auto &dep : transaction->getDependencies())
    {
        if (dfs(dep, visited, recursionStack))
        {
            return true;
        }
    }
    recursionStack.erase(transactionName);
    return false;
}


=== File: ./src/transaction/Transaction.cpp ===
----------------------------------------
/**
 * @ Author: Ke Wang & Siwen Tao
 * @ Email: kw3484@nyu.edu & st5297@nyu.edu
 * @ Create Time: 2024-11-28 21:40:54
 * @ Modified time: 2024-12-05 21:32:47
 */

#include "Transaction.h"

#include <chrono>

Transaction::Transaction(const std::string &name, bool isReadOnly)
    : name(name),
      readOnly(isReadOnly),
      status(TransactionStatus::ACTIVE),
      startTime(std::chrono::system_clock::now().time_since_epoch().count()),
      commitTime(0) {} // Initialize commitTime

std::string Transaction::getName() const { return name; }

bool Transaction::isReadOnly() const { return readOnly; }

TransactionStatus Transaction::getStatus() const { return status; }

void Transaction::setStatus(TransactionStatus newStatus)
{
    status = newStatus;
    if (newStatus == TransactionStatus::COMMITTED)
    {
        commitTime = std::chrono::system_clock::now().time_since_epoch().count();
    }
}

long Transaction::getStartTime() const { return startTime; }

void Transaction::addReadVariable(const std::string &variableName) { readSet.insert(variableName); }

void Transaction::addWriteVariable(const std::string &variableName, int value) { writeSet[variableName] = value; }

const std::set<std::string> &Transaction::getReadSet() const { return readSet; }

const std::map<std::string, int> &Transaction::getWriteSet() const { return writeSet; }

// In src/transaction/Transaction.cpp, add these implementations:
void Transaction::setCommitTime(long time) { commitTime = time; }

long Transaction::getCommitTime() const { return commitTime; }

// tracking the sites that need to be wrote
void Transaction::addSitesWritten(const std::vector<int> &siteIds)
{
    for (int siteId : siteIds)
    {
        sitesWrittenTo.insert(siteId);
    }
}

const std::unordered_set<int> &Transaction::getSitesWrittenTo() const
{
    return sitesWrittenTo;
}
void Transaction::addDependency(const std::string &transactionName)
{
    dependencySet.insert(transactionName);
}

const std::set<std::string> &Transaction::getDependencies() const
{
    return dependencySet;
}


=== File: ./src/transaction/CommandParser.cpp ===
----------------------------------------
/**
 * @ Author: Ke Wang & Siwen Tao
 * @ Email: kw3484@nyu.edu & st5297@nyu.edu
 * @ Create Time: 2024-11-26 20:07:56
 * @ Modified time: 2024-12-05 21:32:51
 */

#include "CommandParser.h"
#include "TransactionManager.h"
#include <sstream>
#include <iostream>
#include <algorithm>
#include <string>

using namespace std;

CommandParser::CommandParser(TransactionManager &tm)
    : transactionManager(tm) {}

// Helper function to trim whitespace
string trim(const string &str)
{
    size_t first = str.find_first_not_of(" \t\n\r");
    if (first == string::npos)
        return "";
    size_t last = str.find_last_not_of(" \t\n\r");
    return str.substr(first, (last - first + 1));
}

// Extract single argument from command like "begin(T1)" -> "T1"
string extractArgument(const string &command)
{
    size_t start = command.find('(');
    size_t end = command.find(')');
    if (start == string::npos || end == string::npos || start >= end)
    {
        return "";
    }
    return trim(command.substr(start + 1, end - start - 1));
}

// Extract multiple arguments from command like "W(T1,x1,101)" -> ["T1", "x1", "101"]
vector<string> extractArguments(const string &command)
{
    vector<string> args;
    size_t start = command.find('(');
    size_t end = command.find(')');

    if (start == string::npos || end == string::npos || start >= end)
    {
        return args;
    }

    string argsStr = command.substr(start + 1, end - start - 1);
    stringstream ss(argsStr);
    string arg;

    while (getline(ss, arg, ','))
    {
        args.push_back(trim(arg));
    }

    return args;
}

void CommandParser::parseCommand(const string &command)
{
    string trimmedCommand = trim(command);

    if (trimmedCommand.empty() || trimmedCommand[0] == '/')
        return;

    if (trimmedCommand.substr(0, 6) == "begin(")
    {
        string txnName = extractArgument(trimmedCommand);
        transactionManager.beginTransaction(txnName, false);
    }
    else if (trimmedCommand.substr(0, 8) == "beginRO(")
    {
        string txnName = extractArgument(trimmedCommand);
        transactionManager.beginTransaction(txnName, true);
    }
    else if (trimmedCommand.substr(0, 2) == "W(")
    {
        vector<string> args = extractArguments(trimmedCommand);
        if (args.size() >= 3)
        {
            transactionManager.write(args[0], args[1], stoi(args[2]));
        }
    }
    else if (trimmedCommand.substr(0, 2) == "R(")
    {
        vector<string> args = extractArguments(trimmedCommand);
        if (args.size() >= 2)
        {
            transactionManager.read(args[0], args[1]);
        }
    }
    else if (trimmedCommand.substr(0, 4) == "end(")
    {
        string txnName = extractArgument(trimmedCommand);
        transactionManager.endTransaction(txnName);
    }
    else if (trimmedCommand == "dump()")
    {
        // Access dataManager through transactionManager
        transactionManager.dump();
    }
    else if (trimmedCommand.substr(0, 5) == "fail(")
    {
        string siteIdStr = extractArgument(trimmedCommand);
        int siteId = stoi(siteIdStr);
        transactionManager.failSite(siteId);
    }
    else if (trimmedCommand.substr(0, 8) == "recover(")
    {
        string siteIdStr = extractArgument(trimmedCommand);
        int siteId = stoi(siteIdStr);
        transactionManager.recoverSite(siteId);
    }
    else
    {
        cerr << "Unknown command: " << command << endl;
    }
}
vector<string> CommandParser::tokenize(const string &str, char delimiter)
{
    vector<string> tokens;
    stringstream ss(str);
    string token;
    while (getline(ss, token, delimiter))
    {
        tokens.push_back(trim(token));
    }
    return tokens;
}


=== File: ./all_contents.txt ===
----------------------------------------



=== File: ./scan.sh ===
----------------------------------------
#!/bin/bash
# Output file
OUTPUT_FILE="all_contents.txt"

# Clear or create output file
> "$OUTPUT_FILE"

# Add header with timestamp
echo "Directory Contents Dump - $(date)" >> "$OUTPUT_FILE"
echo "Current Directory: $(pwd)" >> "$OUTPUT_FILE"
echo "=========================================" >> "$OUTPUT_FILE"
echo >> "$OUTPUT_FILE"

# Find all files while ignoring .git, build dir, and binary files
find . -type f \
    -not -path "*.git*" \
    -not -path "*build*" \
    -not -name "*.o" \
    -not -name "*.exe" \
    -not -name "*.a" \
    -not -name "*.so" \
    -not -name "*.pyc" \
    -not -name "*.class" \
    -not -name "*.jar" \
    -not -name "*.war" \
    -not -name "*.dll" \
    -not -name "*.bin" \
    -print0 | while IFS= read -r -d '' file; do
    
    # Print file header
    echo "=== File: $file ===" >> "$OUTPUT_FILE"
    echo "----------------------------------------" >> "$OUTPUT_FILE"
    
    # Try to cat the file contents, redirect errors to /dev/null
    cat "$file" 2>/dev/null >> "$OUTPUT_FILE"
    
    # Add spacer between files
    echo -e "\n\n" >> "$OUTPUT_FILE"
done

echo "Contents have been saved to $OUTPUT_FILE"


=== File: ./include/CommandParser.h ===
----------------------------------------
/**
 * @ Author: Ke Wang & Siwen Tao
 * @ Email: kw3484@nyu.edu & st5297@nyu.edu
 * @ Create Time: 2024-11-26 20:07:56
 * @ Modified time: 2024-12-05 21:33:27
 */

#ifndef COMMAND_PARSER_H
#define COMMAND_PARSER_H

#include <string>
#include <vector>

class TransactionManager;

class CommandParser {
public:
    CommandParser(TransactionManager& tm);
    void parseCommand(const std::string& command);

private:
    TransactionManager& transactionManager;
    std::vector<std::string> tokenize(const std::string& str, char delimiter);
};

#endif // COMMAND_PARSER_H



=== File: ./include/Transaction.h ===
----------------------------------------
/**
 * @ Author: Ke Wang & Siwen Tao
 * @ Email: kw3484@nyu.edu & st5297@nyu.edu
 * @ Create Time: 2024-11-28 21:40:54
 * @ Modified time: 2024-12-05 21:33:14
 */

#ifndef TRANSACTION_H
#define TRANSACTION_H

#include <string>
#include <set>
#include <map>
#include <chrono>
#include <unordered_set>
#include <vector>

enum class TransactionStatus
{
    ACTIVE,
    COMMITTED,
    ABORTED
};

class Transaction
{
public:
    Transaction(const std::string &name, bool isReadOnly);

    std::string getName() const;
    bool isReadOnly() const;
    TransactionStatus getStatus() const;
    void setStatus(TransactionStatus status);
    long getStartTime() const;
    void setCommitTime(long time);

    void addReadVariable(const std::string &variableName);
    void addWriteVariable(const std::string &variableName, int value);

    const std::set<std::string> &getReadSet() const;
    const std::map<std::string, int> &getWriteSet() const;
    long getCommitTime() const;
    void addSitesWritten(const std::vector<int> &siteIds);
    const std::unordered_set<int> &getSitesWrittenTo() const;

    void addDependency(const std::string &transactionName);
    const std::set<std::string> &getDependencies() const;

private:
    std::string name;
    bool readOnly;
    TransactionStatus status;
    long startTime; // Use timestamp for SSI
    long commitTime;

    std::set<std::string> dependencySet;

    std::set<std::string> readSet;
    std::map<std::string, int> writeSet;
    std::unordered_set<int> sitesWrittenTo;
};

#endif // TRANSACTION_H



=== File: ./include/TransactionManager.h ===
----------------------------------------
/**
 * @ Author: Ke Wang & Siwen Tao
 * @ Email: kw3484@nyu.edu & st5297@nyu.edu
 * @ Create Time: 2024-11-28 21:40:54
 * @ Modified time: 2024-12-05 21:33:11
 */

#ifndef TRANSACTION_MANAGER_H
#define TRANSACTION_MANAGER_H

#include <string>
#include <map>
#include <memory>
#include "Transaction.h"
#include "DataManager.h"

class TransactionManager
{
public:
    TransactionManager(std::shared_ptr<DataManager> dm);
    void processCommand(const std::string &command);

    void beginTransaction(const std::string &transactionName, bool isReadOnly);
    void read(const std::string &transactionName, const std::string &variableName);
    void write(const std::string &transactionName, const std::string &variableName, int value);
    void endTransaction(const std::string &transactionName);
    void dump() const;
    void failSite(int siteId);
    void recoverSite(int siteId);

private:
    std::map<std::string, std::shared_ptr<Transaction>> transactions;
    std::shared_ptr<DataManager> dataManager; // Interface to Data Managers

    std::map<std::string, std::set<std::string>> readTable; // variableName -> transactions that read it
    std::map<std::string, std::set<std::string>> writeTable;

    std::map<std::string, std::string> lastWriter;

    // Helper methods
    void validateAndCommit(std::shared_ptr<Transaction> transaction);
    void abortTransaction(std::shared_ptr<Transaction> transaction);

    bool detectCycle(const std::string &transactionName);
    bool dfs(const std::string &transactionName, std::set<std::string> &visited, std::set<std::string> &recursionStack);
};

#endif // TRANSACTION_MANAGER_H



=== File: ./include/DataManager.h ===
----------------------------------------
/**
 * @ Author: Ke Wang & Siwen Tao
 * @ Email: kw3484@nyu.edu & st5297@nyu.edu
 * @ Create Time: 2024-11-26 20:07:56
 * @ Modified time: 2024-12-05 21:33:24
 */

#ifndef DATA_MANAGER_H
#define DATA_MANAGER_H

#include <string>
#include <map>
#include <vector>
#include <memory>
#include "Site.h"
#include "Transaction.h"

class DataManager {
public:
    DataManager();
    void initializeSites();

    std::shared_ptr<Site> getSite(int siteId);
    std::vector<std::shared_ptr<Site>> getAllSites();

    bool hasCommittedWrite(const std::string& variableName, long startTime);
    void commitTransaction(std::shared_ptr<Transaction> transaction);
    void dump();

    // Methods to route read/write requests to sites
    int read(const std::string& transactionName, const std::string& variableName, long timestamp);
    void write(std::shared_ptr<Transaction> transaction, const std::string& variableName, int value, long commitTime);

    // Methods to handle site failures and recoveries
    void failSite(int siteId);
    void recoverSite(int siteId);

private:
    std::map<int, std::shared_ptr<Site>> sites;
    
    // Structure to track waiting transactions
    struct WaitingRead {
        std::string transactionName;
        std::string variableName;
        long timestamp;
    };
    std::vector<WaitingRead> waitingReads;

    // Helper method to check if a site has stable history
    bool hasSiteStableHistory(std::shared_ptr<Site> site, long timestamp) const;
    bool hasContinuousHistory(std::shared_ptr<Site> site, long fromTime, long toTime) const;
};

#endif // DATA_MANAGER_H


=== File: ./include/Variable.h ===
----------------------------------------
/**
 * @ Author: Ke Wang & Siwen Tao
 * @ Email: kw3484@nyu.edu & st5297@nyu.edu
 * @ Create Time: 2024-11-26 20:07:56
 * @ Modified time: 2024-12-05 21:33:07
 */

#ifndef VARIABLE_H
#define VARIABLE_H

#include <string>
#include <vector>

struct Version {
    int value;
    long commitTime;
};

class Variable {
public:
    Variable(); // Default constructor
    Variable(const std::string& name, int initialValue);

    std::string getName() const;
    int readValue(long timestamp) const;
    void writeValue(int value, long commitTime);
    bool wasModifiedAfter(long timestamp) const;

private:
    std::string name;
    std::vector<Version> versions;
};

#endif // VARIABLE_H



=== File: ./include/Lock.h ===
----------------------------------------
/**
 * @ Author: Ke Wang & Siwen Tao
 * @ Email: kw3484@nyu.edu & st5297@nyu.edu
 * @ Create Time: 2024-11-26 20:07:56
 * @ Modified time: 2024-12-05 21:33:19
 */

#ifndef LOCK_H
#define LOCK_H

#include <iostream>
#include <set>

using namespace std;

#define TOTAL_VARIABLES 20

enum Lock_type
{
    READ_LOCK,
    WRITE_LOCK,
    NO_LOCK
};

class Lock
{
public:
    Lock_type type;
    // TODO: Modify the DS
    set<int> transactions;
    Lock(Lock_type type, set<int> transactions);
};

#endif


=== File: ./include/Site.h ===
----------------------------------------
/**
 * @ Author: Ke Wang & Siwen Tao
 * @ Email: kw3484@nyu.edu & st5297@nyu.edu
 * @ Create Time: 2024-11-26 20:07:56
 * @ Modified time: 2024-12-05 21:33:17
 */

#ifndef SITE_H
#define SITE_H

#include <string>
#include <map>
#include <mutex>
#include <unordered_set>
#include "Variable.h"

enum class SiteStatus
{
    UP,
    DOWN,
    RECOVERING
};

class Site
{
public:
    Site(int id);
    int getId() const;
    SiteStatus getStatus() const;
    void setStatus(SiteStatus status);

    int readVariable(const std::string &variableName, long timestamp);
    void writeVariable(const std::string &variableName, int value, long commitTime);

    void fail();
    void recover();
    bool hasVariable(const std::string &variableName) const;
    bool hasCommittedWrite(const std::string &variableName, long startTime) const;
    void dump() const;
    const std::vector<std::pair<long, long>> &getFailureTimes() const;

private:
    int id;
    SiteStatus status;
    std::mutex siteMutex;
    std::map<std::string, Variable> variables;
    std::unordered_set<std::string> unavailableVariables;
    void initializeVariables();
    std::vector<std::pair<long, long>> failureTimes;
};

#endif // SITE_H



=== File: ./.vscode/settings.json ===
----------------------------------------
{
    "files.associations": {
        "__bit_reference": "cpp",
        "__config": "cpp",
        "__debug": "cpp",
        "__errc": "cpp",
        "__hash_table": "cpp",
        "__locale": "cpp",
        "__mutex_base": "cpp",
        "__node_handle": "cpp",
        "__split_buffer": "cpp",
        "__threading_support": "cpp",
        "__tree": "cpp",
        "__verbose_abort": "cpp",
        "array": "cpp",
        "atomic": "cpp",
        "bitset": "cpp",
        "cctype": "cpp",
        "charconv": "cpp",
        "clocale": "cpp",
        "cmath": "cpp",
        "complex": "cpp",
        "cstdarg": "cpp",
        "cstddef": "cpp",
        "cstdint": "cpp",
        "cstdio": "cpp",
        "cstdlib": "cpp",
        "cstring": "cpp",
        "ctime": "cpp",
        "cwchar": "cpp",
        "cwctype": "cpp",
        "deque": "cpp",
        "exception": "cpp",
        "fstream": "cpp",
        "initializer_list": "cpp",
        "iomanip": "cpp",
        "ios": "cpp",
        "iosfwd": "cpp",
        "iostream": "cpp",
        "istream": "cpp",
        "limits": "cpp",
        "locale": "cpp",
        "map": "cpp",
        "mutex": "cpp",
        "new": "cpp",
        "optional": "cpp",
        "ostream": "cpp",
        "ratio": "cpp",
        "regex": "cpp",
        "set": "cpp",
        "sstream": "cpp",
        "stdexcept": "cpp",
        "streambuf": "cpp",
        "string": "cpp",
        "string_view": "cpp",
        "system_error": "cpp",
        "tuple": "cpp",
        "typeinfo": "cpp",
        "unordered_map": "cpp",
        "variant": "cpp",
        "vector": "cpp",
        "algorithm": "cpp",
        "functional": "cpp",
        "unordered_set": "cpp",
        "bit": "cpp",
        "*.tcc": "cpp",
        "chrono": "cpp",
        "compare": "cpp",
        "concepts": "cpp",
        "condition_variable": "cpp",
        "iterator": "cpp",
        "memory": "cpp",
        "memory_resource": "cpp",
        "numeric": "cpp",
        "random": "cpp",
        "type_traits": "cpp",
        "utility": "cpp",
        "format": "cpp",
        "numbers": "cpp",
        "semaphore": "cpp",
        "span": "cpp",
        "stop_token": "cpp",
        "text_encoding": "cpp",
        "thread": "cpp"
    }
}


